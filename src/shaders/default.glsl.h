#ifndef __SHADER_SOURCE_DEFAULT_H_
#define __SHADER_SOURCE_DEFAULT_H_
static const char *__shader_source_default = "#ifdef VERTEX_SHADER\n\nlayout (location = 0) in vec3 position;\nlayout (location = 1) in vec2 uv0;\nlayout (location = 2) in vec4 color0;\nlayout (location = 3) in vec3 normal0;\n\nuniform mat4 projection;\nuniform mat4 view;\nuniform mat4 view_light;\nuniform mat4 xform;\n\nout vec2 uv;\nout vec4 color;\nout vec3 normal;\nout vec3 frag_pos;\nout vec4 frag_pos_light_space;\n\nvoid main() {\n	uv = uv0;\n    color = color0;\n	normal = transpose(inverse(mat3(xform))) * normalize(normal0);\n	frag_pos = vec3(xform * vec4(position, 1.0));\n	frag_pos_light_space = view_light * vec4(frag_pos, 1.0);\n	\n	gl_Position = projection * view * xform * vec4(position, 1.0);\n}\n\n#else\n\nuniform sampler2D texture0;\nuniform sampler2D shadow_map;\n\nin vec2 uv;\nin vec4 color;\nin vec3 normal;\nin vec3 frag_pos;\nin vec4 frag_pos_light_space;\n\nuniform vec3 view_pos;\n\n// light_pos = vec3(-1.0f, 2.0f, 5.0f)\n\nfloat ShadowCalculation(vec4 fragPosLightSpace) {\n    // perform perspective divide\n    vec3 projCoords = fragPosLightSpace.xyz / fragPosLightSpace.w;\n    // transform to [0,1] range\n    projCoords = projCoords * 0.5 + 0.5;\n    // get closest depth value from light's perspective (using [0,1] range fragPosLight as coords)\n    float closestDepth = texture(shadow_map, projCoords.xy).r; \n    // get depth of current fragment from light's perspective\n    float currentDepth = projCoords.z;\n    // calculate bias (based on depth map resolution and slope)\n    vec3 normal = normalize(normal);\n    vec3 lightDir = normalize(vec3(-1.0f, 2.0f, 5.0f) - frag_pos);\n    float bias = max(0.05 * (1.0 - dot(normal, lightDir)), 0.005);\n    // check whether current frag pos is in shadow\n    // float shadow = currentDepth - bias > closestDepth  ? 1.0 : 0.0;\n    // PCF\n    float shadow = 0.0;\n    vec2 texelSize = 1.0 / textureSize(shadow_map, 0);\n    for(int x = -1; x <= 1; ++x)\n    {\n        for(int y = -1; y <= 1; ++y)\n        {\n            float pcfDepth = texture(shadow_map, projCoords.xy + vec2(x, y) * texelSize).r; \n            shadow += currentDepth - bias > pcfDepth  ? 1.0 : 0.0;        \n        }    \n    }\n    shadow /= 9.0;\n    \n    // keep the shadow at 0.0 when outside the far_plane region of the light's frustum.\n    if(projCoords.z > 1.0)\n        shadow = 0.0;\n	\n    return shadow;\n}\n\nvoid main() {\n	vec4 frag_color = texture(texture0, uv);\n    vec3 normal = normalize(normal);\n    vec3 light_color = vec3(0.3);\n    \n	if (frag_color.w == 0.0f) {\n		discard;\n	}\n	\n	// ambient\n    vec3 ambient = 0.3 * light_color;\n	\n    // diffuse\n    vec3 light_dir = normalize(vec3(-1.0f, 2.0f, 5.0f) - frag_pos);\n    float diff = max(dot(light_dir, normal), 0.0);\n    vec3 diffuse = diff * light_color;\n    \n	// specular\n    vec3 viewDir = normalize(view_pos - frag_pos);\n    vec3 reflectDir = reflect(-light_dir, normal);\n    float spec = 0.0;\n    vec3 halfwayDir = normalize(light_dir + viewDir);  \n    spec = pow(max(dot(normal, halfwayDir), 0.0), 64.0);\n    vec3 specular = spec * light_color;    \n    \n	// calculate shadow\n    float shadow = ShadowCalculation(frag_pos_light_space);                      \n    vec3 lighting = (ambient + (1.0 - shadow) * (diffuse + specular)) * frag_color.rgb;    \n	\n	gl_FragColor = vec4(lighting, frag_color.w);\n}\n\n#endif";
#endif